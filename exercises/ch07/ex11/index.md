# 解答

## DynamicSizeArray の push の平均時間計算量

### pushメソッドは以下の動作を行う

- 通常時(容量に余裕がある場合)：末尾に値を追加するだけなのでO(1)の時間

- 容量不足で再配置が必要な場合：
  - 新しい固定長配列を2倍のサイズで作る
  - 旧配列にすべての用をを新しい配列にコピーする。コピーにかかる時間はコピーする要素数に比例し、サイズがkの配列をコピーするのにO(k)の時間がかかる

### 再配置が起こる回数

配列のサイズが倍々に増えるため、要素数nに対して再配置はおおよそ
log2(n)回発生する。

### コピーされる要素数の合計

再配置ごとのコピー回数は以下のように増加：
1+2+4+8+...+2^(log2(n)) = 2^(log2(n+1)) - 1 = 2n - 1 = O(n)

### 各pushの平均時間計算量(アモルタイズド時間)

- 合計コピー回数はO(n)

- これをn回のpushで割ると、平均して1回のpushでかかるコピーコストはO(1)

## copyA と copyB の時間計算量

配列の長さをnとする。

### copyA

- 配列の長さがnの配列を作成（Array(n)はO(1)）

- forループでn回、要素をコピー

- 時間計算はO(n)

### copyB

- 空配列からスタート

- pushをn回呼ぶ

このpushがJavaScriptの標準配列ではどのように実装されているかが重要だが、ほとんどのエンジンでは動的配列と同様に容量倍増で再配置を行うため、前述のpushと同様に、

- 1回のpushのアモルタイズド時間はO(1)

- したがって、n回のpushでO(n)

## まとめ

- DynamicSizeArray の push は最悪時 O(n) だが、平均 (アモルタイズド) では O(1)

- copyA は単純にループで n 回のコピー → O(n)

- copyB は push を n 回呼ぶ動的配列のコピー → アモルタイズド O(n)

- 計算量の観点ではどちらも O(n) で同じだが、実装の違いにより定数時間の差はありうる

- 「copyA は一度で必要な配列を確保してからコピーする」、「copyB は容量不足時に配列の再確保・コピーが起こり得るが、アモルタイズドで見ると結局 O(n)」
