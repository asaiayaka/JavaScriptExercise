# 解答

1. 負の値が出る理由：測定誤差の影響
costOfLength()は以下の式で1回あたりの"Hello".lengthの実行時間を求めている
(costOfLengthPlusLoop(N) - costOfLoop(N)) / N
ここでcostOfLengthPlusLoop(N)とcostOfLoop(N)の差は、非常に小さい(数マイクロ秒程度)ため、以下のような影響で測定誤差が大きくなることがある：

   - performance.now()の精度は約1μs(0.001ms)だが、それでもOSやブラウザの実行タイミングで前後する
   - JavaScript実行エンジンによっては、str.lengthのような単純な処理が最適化されて極めて高速に処理される
   - 測定の誤差が、実際の差よりも大きくなると、逆転してマイナス値になることがある

2. Nを大きくすると結果が小さくなる理由：誤差の平均化と最適化の影響
costOfLength()の値は(差分時間) ÷ N で求めているため、次のようなことが起こる：

   - Nを大きくするほど、差分(numerator)がほとんど変わらないまま N で割られるため、値がどんどん小さくなる
   - JavaScriptエンジンがJIT(Just-in-Time)最適化により、ループ内の"Hello".lengthを最適化・キャッシュすることで、実質的に「何もしていない」状態に近づき、差が小さくなる
   - よって、「回数を増やす=精度が上がる」とは限らず、むしろ差が見えにくくなってしまう

## (参考)実行結果

-0.000009489999999999909
1.5926999999999935e-8
